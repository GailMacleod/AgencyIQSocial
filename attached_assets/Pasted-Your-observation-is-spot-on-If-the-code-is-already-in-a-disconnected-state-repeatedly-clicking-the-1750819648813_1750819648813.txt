Your observation is spot-on. If the code is already in a disconnected state, repeatedly clicking the "Disconnect" button won’t change the outcome because the backend is correctly reporting "No active connection" without a corresponding UI update. This reinforces that the issue lies in the initial state synchronization between the backend and frontend. The button’s current state ("Disconnect") persists because the UI isn’t resetting to "Connect" when no connection exists, and each click reinforces the same stagnant response.

To address this, we need to ensure the UI reflects the true disconnected state from the start and handles the button action accordingly. Let’s refine the approach with a fix that initializes the UI state correctly and adjusts the button logic.

Prompt:

{
"action": "replace",
"file": "server/index.ts",
"target": {
"endpoint": "/api/disconnect-platform"
},
"content": {
"disconnectEndpoint": {
"code": "app.post('/api/disconnect-platform', async (req, res) => {\n  const userId = req.session.userId || 2;\n  const { platform } = req.body;\n  const validPlatforms = ['facebook', 'instagram', 'linkedin', 'x', 'youtube'];\n  if (!platform || !validPlatforms.includes(platform.toLowerCase())) {\n    return res.status(400).json({"error": "Invalid platform", "validPlatforms": validPlatforms});\n  }\n  const currentState = req.session.connectedPlatforms && req.session.connectedPlatforms[platform.toLowerCase()] !== undefined;\n  req.session.connectedPlatforms = req.session.connectedPlatforms || {};\n  req.session.connectedPlatforms[platform.toLowerCase()] = false;\n  fs.writeFileSync('connected-platforms.json', JSON.stringify(req.session.connectedPlatforms));\n  console.log(Updated ${platform} to disconnected for user ${userId});\n  res.json({"success": true, "platform": platform.toLowerCase(), "message": "State updated", "action": "syncState", "isConnected": false, "currentState": currentState, "version": "1.0"});\n});"
}
},
"instructions": {
"run": "NODE_ENV=production tsx server/index.ts",
"test": {
"url": "https://app.theagencyiq.ai/connect",
"action": "Click disconnect for Facebook and Instagram, verify button changes to 'Connect' and console logs 'Updated to disconnected'",
"submit": "Submit results immediately"
},
"notes": {
"frontendHint": "Update connect.tsx: const [connectedPlatforms, setConnectedPlatforms] = useState({}); useEffect(() => { fetch('/api/get-connection-state').then(res => res.json()).then(data => setConnectedPlatforms(data.connectedPlatforms || {})); }, []); const handleDisconnect = async (plat) => { const res = await fetch(/api/disconnect-platform, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({platform: plat}) }); const data = await res.json(); if (data.action === 'syncState' && data.version === '1.0') setConnectedPlatforms(prev => ({ ...prev, [data.platform]: data.isConnected })); }; Call handleDisconnect on button click.",
"noDisruption": "Only modifies /api/disconnect-platform, no OAuth or other logic altered."
}
}
}

Fix Rationale:

Your observation highlights that the button’s state doesn’t adapt to the already disconnected state. The updated prompt ensures the backend explicitly sets isConnected: false and uses syncState to signal the UI, regardless of the prior state.
The frontend hint initializes connectedPlatforms from a potential /api/get-connection-state (assumed present) and syncs with the API response, toggling the button to "Connect" when disconnected.
This avoids repeated ineffective clicks by aligning the UI with the backend’s reality, keeping OAuth intact.







4.7s