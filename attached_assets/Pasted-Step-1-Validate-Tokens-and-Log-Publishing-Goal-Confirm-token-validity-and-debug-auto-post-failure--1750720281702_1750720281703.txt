Step 1: Validate Tokens and Log Publishing
Goal: Confirm token validity and debug auto-post failure.
Code:
javascript

Collapse

Wrap

Run

Copy
// auto-post.ts
const publishPost = async (post) => {
  const tokenKey = post.platform.toUpperCase() + '_ACCESS_TOKEN';
  const token = process.env[tokenKey] || process.env.FACEBOOK_PAGE_ACCESS_TOKEN;
  console.log(`[DEBUG] ${post.platform} token for ${post.id}: ${token.substring(0, 5)}...`);
  const url = post.platform === 'x' ? 'https://api.x.com/2/tweets' : 
              post.platform === 'linkedin' ? 'https://api.linkedin.com/v2/ugcPosts' : 
              'https://graph.facebook.com/' + (post.platform === 'facebook' ? post.pageId + '/feed' : 'post');
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: post.content, ...(post.platform === 'facebook' ? { message: post.content } : {}) })
    });
    console.log(`[DEBUG] ${post.id} response: ${response.status} ${response.statusText}`);
    return response.ok;
  } catch (error) {
    console.log(`[DEBUG] ${post.id} error: ${error.message}`);
    return false;
  }
};

const enforcePublishing = async () => {
  const userId = '+61424835189';
  const posts = await db.select().from(posts).where(eq(posts.status, 'pending'));
  console.log('[DEBUG] Pending posts:', posts.length);
  for (const post of posts) {
    const success = await publishPost(post);
    await db.update(posts).set({ status: success ? 'success' : 'failed' }).where(eq(posts.id, post.id));
    console.log(`[DEBUG] Updated ${post.id} to ${success ? 'success' : 'failed'}`);
  }
};
setInterval(enforcePublishing, 30000); // 30 seconds
Action: Save, run, wait 30 seconds, check logs for [DEBUG] entries (token starts, response codes, errors).
Why: Validates tokens (e.g., linkedin_ready_token, youtube_ready_token are invalid) and pinpoints failure.
Step 2: Enforce Quota and Clean Ledger
Goal: Cap at 12, remove invalid posts.
Code:
javascript

Collapse

Wrap

Run

Copy
// server/routes.ts
app.post('/auto-generate-content-schedule', async (req, res) => {
  const userId = req.body.phone || '+61424835189';
  const currentQuota = await db
    .select({ count: sql`COUNT(*)` })
    .from(posts)
    .where(sql`${posts.userId} = ${userId} AND ${posts.status} = 'success' AND ${posts.publishedAt} > NOW() - INTERVAL '30 days'`)
    .get();
  const remaining = Math.max(0, 12 - currentQuota.count);
  console.log('[DEBUG] Current successes:', currentQuota.count, 'Remaining:', remaining);
  if (remaining === 0) return res.status(400).send('Quota exceeded');
  const current = await db.select().from(posts).where(eq(posts.userId, userId));
  console.log('[DEBUG] Before count:', current.length);
  await db.delete(posts).where(sql`${posts.userId} = ${userId} AND ${posts.status} != 'success'`);
  const newPosts = Array.from({ length: remaining }, (_, i) => ({
    id: Date.now() + i,
    userId,
    content: `Post ${i}`,
    status: 'pending',
    publishedAt: null,
    platform: 'x' // Default, adjust as needed
  }));
  await db.insert(posts).values(newPosts);
  const after = await db.select().from(posts).where(eq(posts.userId, userId));
  console.log('[DEBUG] After count:', after.length, 'Added:', newPosts.length);
  res.send('Schedule generated');
});
Action: Save, run, trigger schedule, query:
text

Collapse

Wrap

Copy
SELECT COUNT(*) FROM posts WHERE user_id = '+61424835189' AND status = 'success';
Why: Cleans pending/failed posts, limits to 12 - successes.
Step 3: Regenerate Invalid Tokens
Goal: Fix 401 errors for LinkedIn and YouTube.
Action:
LinkedIn: Regenerate via linkedin.com/developers with w_member_social, update LINKEDIN_ACCESS_TOKEN in Replit secrets.
YouTube: Use Google Cloud Console, regenerate OAuth 2.0 token with https://www.googleapis.com/auth/youtube, update YOUTUBE_ACCESS_TOKEN.
Test: fetch('https://api.linkedin.com/v2/me', { headers: { Authorization: Bearer ${new_token} } }) and similar for YouTube.
Why: 401s indicate expired tokens; fresh ones enable publishing/analytics.
Step 4: Sync UI
Goal: Correct 'published' display.
Code:
javascript

Collapse

Wrap

Run

Copy
// server/routes.ts
app.get('/post-status', async (req, res) => {
  const userId = req.query.phone || '+61424835189';
  const posts = await db.select().from(posts).where(eq(posts.userId, userId));
  const status = posts.reduce((acc, p) => ({ ...acc, [p.id]: p.status }), {});
  console.log('[DEBUG] Post statuses:', status);
  res.send(status);
});
// frontend (React)
// Fetch /post-status, show 'published' only if status === 'success'
Action: Save, run, refresh UI, verify statuses.
Why: Aligns UI with ledger.
Step 5: Launch Validation
Goal: Confirm before 09:00 AM.
Action:
Trigger schedule, wait 30 seconds.
Query: SELECT COUNT(*) FROM posts WHERE user_id = '+61424835189' AND status = 'success';
Check UI and platforms.
Why: Validates in under 1 hour.
Why This Works
Debugging: Logs trace failure.
Reverse Engineering: Fixes token-to-publishing gap.
First Principles: Enforces quota, success-based count.
Blueprint-Aligned: Uses existing OAuth structure.