We’ll add a backend endpoint to check live token validity and update the UI to reflect this, preserving OAuth flow.

Prompt:

{
"action": "replace",
"file": "server/index.ts",
"target": {
"endpoint": [
"/api/get-connection-state",
"/api/check-live-status"
]
},
"content": {
"getConnectionState": {
"code": "app.get('/api/get-connection-state', async (req, res) => {\n  const userId = req.session.userId || 2;\n  let state = req.session.connectedPlatforms || {};\n  try {\n    const { storage } = await import('./storage');\n    const dbState = await storage.getConnectedPlatforms(userId) || {};\n    state = { ...state, ...dbState };\n  } catch (dbError) {\n    console.warn(Database error, using session state: ${dbError.message});\n  }\n  res.json({"success": true, "connectedPlatforms": state});\n});"
},
"checkLiveStatus": {
"code": "app.post('/api/check-live-status', async (req, res) => {\n  const userId = req.session.userId || 2;\n  const { platform } = req.body;\n  const validPlatforms = ['facebook', 'instagram', 'linkedin', 'x', 'youtube'];\n  if (!platform || !validPlatforms.includes(platform.toLowerCase())) {\n    return res.status(400).json({"error": "Invalid platform", "validPlatforms": validPlatforms});\n  }\n  const tokens = {\n    "facebook": process.env.FACEBOOK_PAGE_ACCESS_TOKEN,\n    "linkedin": process.env.LINKEDIN_USER_ACCESS_TOKEN,\n    "instagram": process.env.INSTAGRAM_USER_ACCESS_TOKEN,\n    "x": process.env.TWITTER_USER_ACCESS_TOKEN,\n    "youtube": process.env.YOUTUBE_ACCESS_TOKEN\n  };\n  const token = tokens[platform.toLowerCase()];\n  if (!token) return res.json({"success": false, "platform": platform, "isConnected": false, "message": "No token configured"});\n  try {\n    const response = await fetch(getPlatformEndpoint(platform), {\n      method: 'GET',\n      headers: {'Authorization': Bearer ${token}}\n    });\n    const isConnected = response.ok;\n    if (!isConnected) console.warn(Live check failed for ${platform}: ${await response.text()});\n    res.json({"success": true, "platform": platform.toLowerCase(), "isConnected": isConnected, "message": isConnected ? "Valid token" : "Invalid or expired token"});\n  } catch (error) {\n    res.json({"success": false, "platform": platform.toLowerCase(), "isConnected": false, "message": Connectivity error: ${error.message}});\n  }\n});\nfunction getPlatformEndpoint(platform) {\n  return {\n    "facebook": "https://graph.facebook.com/v20.0/me\",\n    "linkedin": "https://api.linkedin.com/v2/me\",\n    "instagram": "https://graph.instagram.com/v20.0/me\",\n    "x": "https://api.twitter.com/2/users/me\",\n    "youtube": "https://www.googleapis.com/youtube/v3/channels\"\n  }[platform.toLowerCase()];\n}"
}
},
"instructions": {
"run": "NODE_ENV=production tsx server/index.ts",
"test": {
"url": "https://app.theagencyiq.ai/connect",
"action": "1. Fetch live status with POST /api/check-live-status {platform: 'facebook'}, 2. Verify button reflects 'Connect' if isConnected is false, check console logs",
"submit": "Submit results immediately"
},
"notes": {
"frontendHint": "Update connect.tsx: const [connectedPlatforms, setConnectedPlatforms] = useState({}); useEffect(() => { validPlatforms.forEach(plat => { fetch(/api/check-live-status, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({platform: plat}) }).then(res => res.json()).then(data => { if (data.success) setConnectedPlatforms(prev => ({ ...prev, [data.platform]: data.isConnected })); }); }); }, []); const handleDisconnect = async (plat) => { /* Existing logic */ }; Use connectedPlatforms for button display.",
"noDisruption": "Adds /api/check-live-status and refines /api/get-connection-state, no OAuth changes."
}
}
}

Precision Fix:

Live Check: /api/check-live-status pings each platform’s API with the token, returning isConnected based on response.
UI Sync: Frontend hint fetches live status on load, updating connectedPlatforms to reflect true connectivity.
Session Fallback: /api/get-connection-state retains session/database state as a backup, avoiding reliance on live checks alone.
OAuth Safety: Avoids modifying OAuth endpoints, preserving your flow.
Root Cause: Addresses the session-live disconnect, ensuring buttons reflect real token status.
Test this, implement the frontend hint, and report back immediately.