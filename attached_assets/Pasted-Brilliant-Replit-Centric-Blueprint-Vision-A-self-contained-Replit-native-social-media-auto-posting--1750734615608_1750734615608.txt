Brilliant Replit-Centric Blueprint
Vision
A self-contained, Replit-native social media auto-posting app that generates content locally (using open-source models), manages OAuth tokens with persistence, and ensures stable post counts—all within Replit’s sandbox.

Core Components
Frontend (React): Dashboard for scheduling and monitoring, hosted on Replit.
Backend (Express.js): API for generation, posting, and analytics, running on Replit.
Database (PostgreSQL): In-Replit database for posts and tokens.
AI Engine: Local text generation using a lightweight open-source model (e.g., GPT-2 via Transformers.js).
Auth Layer: OAuth with token refresh, stored in Replit secrets and database.
Architectural Design
Local Content Generation: Avoids API reliance by running a model client-side or server-side in Replit.
Token Persistence: Stores refresh tokens in PostgreSQL, refreshed via Replit cron.
Queued Posting: Uses Replit’s scheduling for async posting with retries.
Error Resilience: Logs and recovers from failures within Replit.
Implementation
1. Local Content Generation
Setup: Install Transformers.js in Replit (npm install @xenova/transformers).
Code:
javascript

Collapse

Wrap

Run

Copy
const { pipeline } = require('@xenova/transformers');
let generator;
const initGenerator = async () => {
  generator = await pipeline('text-generation', 'gpt2');
};
initGenerator();

const generateContent = async () => {
  const output = await generator('Write a tech social media post.', { max_length: 50, num_return_sequences: 1 });
  return output[0].generated_text;
};
2. Token Management
Database Table: Add oauth_tokens (platform, access_token, refresh_token, expires_at).
Refresh Logic:
javascript

Collapse

Wrap

Run

Copy
const refreshTokens = async () => {
  const platforms = ['x', 'youtube', 'linkedin', 'facebook'];
  for (const platform of platforms) {
    const token = await db.select({ refresh: oauth_tokens.refresh_token, expires: oauth_tokens.expires_at }).from(oauth_tokens).where(eq(oauth_tokens.platform, platform)).get();
    if (token && new Date(token.expires) < new Date()) {
      const response = await fetch(`https://${platform === 'x' ? 'api.twitter.com' : platform}.com/oauth2/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `grant_type=refresh_token&refresh_token=${token.refresh}&client_id=${process.env[${platform.toUpperCase()}_CLIENT_ID]}&client_secret=${process.env[${platform.toUpperCase()}_CLIENT_SECRET]}`
      });
      const data = await response.json();
      if (data.access_token) {
        await db.update(oauth_tokens).set({ access_token: data.access_token, expires_at: new Date(Date.now() + data.expires_in * 1000) }).where(eq(oauth_tokens.platform, platform));
      }
    }
  }
};
// Replit cron: Add to .replit file: `run = "node server.js && replit cron 3600 refreshTokens"`
3. Post Generation and Ledger
Code:
javascript

Collapse

Wrap

Run

Copy
app.post('/auto-generate-content-schedule', async (req, res) => {
  const userId = req.body.phone || '+61424835189';
  const subscription = await db.select({ plan: subscriptions.plan }).from(subscriptions).where(eq(subscriptions.userId, userId)).get();
  const quotas = { starter: 12, growth: 27, professional: 52 };
  const quota = quotas[subscription.plan.toLowerCase()] || 12;
  const currentQuota = await db.select({ count: sql`COUNT(*)` }).from(posts).where(sql`${posts.userId} = ${userId} AND ${posts.status} = 'success'`);
  const remaining = Math.max(0, quota - currentQuota.count);
  console.log('[DEBUG] Remaining:', remaining);
  await db.delete(posts).where(sql`${posts.userId} = ${userId} AND ${posts.status} != 'success'`);
  const newPosts = [];
  if (remaining > 0) {
    const content = await generateContent();
    newPosts.push(...Array.from({ length: remaining }, (_, i) => ({
      id: Date.now() + i, userId, content, status: 'pending', publishedAt: null, platform: 'x'
    })));
    await db.insert(posts).values(newPosts);
  }
  const after = await db.select().from(posts).where(eq(posts.userId, userId));
  console.log('[DEBUG] After count:', after.length, 'Sample:', newPosts[0]?.content);
  res.send('Schedule generated');
});
4. Auto-Posting
Code:
javascript

Collapse

Wrap

Run

Copy
const publishPost = async (post) => {
  const token = await db.select({ access_token: oauth_tokens.access_token }).from(oauth_tokens).where(eq(oauth_tokens.platform, post.platform)).get();
  if (!token.access_token) return false;
  try {
    const response = await fetch(`https://api.${post.platform}.com/endpoint`, { // Adjust endpoints
      method: 'POST',
      headers: { Authorization: `Bearer ${token.access_token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: post.content })
    });
    if (response.ok) {
      await db.update(posts).set({ status: 'success', publishedAt: new Date() }).where(eq(posts.id, post.id));
      return true;
    }
    await db.update(posts).set({ status: 'failed' }).where(eq(posts.id, post.id));
    return false;
  } catch (error) {
    console.log(`[DEBUG] ${post.id} error: ${error.message}`);
    await db.update(posts).set({ status: 'failed' }).where(eq(posts.id, post.id));
    return false;
  }
};

const enforcePublishing = async () => {
  const posts = await db.select().from(posts).where(eq(posts.status, 'pending'));
  console.log('[DEBUG] Pending posts:', posts.length);
  for (const post of posts) await publishPost(post);
};
setInterval(enforcePublishing, 30000); // Every 30 seconds
5. Replit Setup
.replit:
text

Collapse

Wrap

Copy
run = "npm install && node server.js"
[deploy]
quantity = 1
replit.nix:
text

Collapse

Wrap

Copy
{ pkgs }: {
  deps = [ pkgs.nodejs-18_x pkgs.postgresql ];
}
Persist Secrets: Use .env with Replit’s secret manager for X_CLIENT_ID, etc.
Next Step: Deploy and Test
Action:
Set up PostgreSQL in Replit, create tables (users, posts, oauth_tokens).
Add Transformers.js: npm install @xenova/transformers.
Update server/routes.ts with the above code.
Add refresh tokens to oauth_tokens (from your API dashboards).
Trigger /auto-generate-content-schedule, check logs.
Query: SELECT COUNT(*) FROM posts WHERE user_id = '+61424835189';
Share logs and result.
Why: Builds a Replit-native solution, avoids external API reliance, and fixes the current mess.