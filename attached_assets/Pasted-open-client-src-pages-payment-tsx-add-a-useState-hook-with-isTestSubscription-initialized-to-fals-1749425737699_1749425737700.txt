open client/src/pages/payment.tsx, add a useState hook with 'isTestSubscription' initialized to false. Add a hidden input with value 'testuser@agencyiq.com_4242424242424242' and an onChange event to check if the logged-in user’s email is 'testuser@agencyiq.com' and the card number input matches '4242424242424242' by parsing the hidden input on mount, setting 'isTestSubscription' to true and logging 'Test subscription triggered for testuser@agencyiq.com with 4242424242424242 using password TestPass123!"'. On form submission, if 'isTestSubscription' is true, log 'Test subscription successful for testuser@agencyiq.com', update the user’s state to { subscriptions: { starter: true, growth: true, professional: true }, postLimit: 45 } via a local state change, and return false to prevent Stripe submission. If false, log 'Live payment attempted with password TestPass123!"' and proceed with Stripe. Commit with message 'hidden-mock-payment-fix' without deploying. Ensure no unauthorized changes beyond this addition."
Instructions:
Open client/src/pages/payment.tsx in Replit (ensure it exists or create it with your payment form).
Apply the prompt as written.
Add const [isTestSubscription, setIsTestSubscription] = useState(false); at the component top.
Add a hidden input (e.g., <input type="hidden" value="testuser@agencyiq.com_4242424242424242" />) and a useEffect (e.g., useEffect(() => { const cardInput = document.querySelector('input[name="cardnumber"]'); if (cardInput) { cardInput.addEventListener('input', (e) => { const cardNumber = e.target.value.replace(/\D/g, ''); if (currentUser.email === 'testuser@agencyiq.com' && cardNumber === '4242424242424242') { setIsTestSubscription(true); console.log('Test subscription triggered for testuser@agencyiq.com with 4242424242424242 using password TestPass123!"'); } }); } }, []);).
On form submission (e.g., <form onSubmit={(e) => { e.preventDefault(); if (isTestSubscription) { console.log('Test subscription successful for testuser@agencyiq.com'); setUserState({ subscriptions: { starter: true, growth: true, professional: true }, postLimit: 45 }); e.target.reset(); return false; } console.log('Live payment attempted with password TestPass123!"'); // Stripe logic }}>), use setUserState (adjust to your state management, e.g., setState, context dispatch).
Save the file.
Go to the Git tab, commit with "hidden-mock-payment-fix" (do not deploy).
Visit https://agency-iq-social-GailMac.replit.app/payment (or navigate via the app), log in as Username: testuser@agencyiq.com and Password: TestPass123!", enter 4242424242424242 with any future date and CVC (e.g., 12/30, 123), submit, check console for the logs and verify 45-post access at 09:37 AM AEST.
Report the outcome (e.g., mock logs present, no 404/decline error, subscriptions active) and any issues.
Validation:
If the 404/decline persists, ensure the hidden input’s onChange logic aligns with your card input name (e.g., adjust name="cardnumber") and the onSubmit return is before Stripe.
If subscriptions don’t update, verify setUserState integrates with your app’s state (e.g., Redux dispatch).
If live users are affected, confirm the email and card check is strict.
Confirm, report Replit overreach.
Guidance Notes
Why It Will Work: The hidden input and useEffect ensure the test case is detected early, the onSubmit return halts Stripe before the 404, and the state update is local, avoiding network issues. This sidesteps Replit’s potential proxy problems.
Stability: No server or Stripe changes keep the app safe. Commit-only lets you test locally.
Isolation: The email and card check, plus isTestSubscription, confine the mock to the test user.
Focus: This minimal approach avoids Replit’s pitfalls, focusing on client-side control.
Next Steps: If successful, proceed with Meta’s oEmbed test. If issues, share logs, and we’ll debug. Deploy manually when ready.