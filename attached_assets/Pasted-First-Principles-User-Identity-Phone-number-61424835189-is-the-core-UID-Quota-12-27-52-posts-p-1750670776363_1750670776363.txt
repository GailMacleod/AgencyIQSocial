First Principles
User Identity: Phone number (+61424835189) is the core UID.
Quota: 12/27/52 posts per 30 days, only successful posts count, no carryover.
Publishing: One post per approval, no doubling, 99.9% success rate.
System: React frontend, Express.js backend, PostgreSQL database, existing OAuth tokens.
Problem: Post doubling from retries, quota miscalculation, Replit instability.
Reverse-Engineering Approach
Start with the end goal: a user approves one post, it publishes once, counts once if successful.
Trace backward: Check post approval, publishing logic, retry service, and ledger updates.
Simplify: Use existing data model, avoid new features, fix root causes.
Step-by-Step Plan for Replit
Step 1: Lock OAuth (Short Prompt)
Goal: Prevent Replit from altering working tokens.
Code:
javascript

Collapse

Wrap

Run

Copy
// server/routes.ts
// Comment out auto-repair
// autoRepairToken(platform); // Disabled
console.log('OAuth locked:', process.env.X_ACCESS_TOKEN); // Verify
Action: Save, run Replit, check logs for token output.
Why: Stops looping, preserves X success.
Step 2: Trace Subscriber Path (Short Prompt)
Goal: Find where posts double.
Code:
javascript

Collapse

Wrap

Run

Copy
// server/routes.ts
app.post('/approve-post', (req, res) => {
  const userId = req.body.phone; // +61424835189
  console.log('Approval triggered for', userId); // Log entry
  // Existing publish logic here
  res.send('Approved');
});
Action: Save, run, approve a post, check logs for duplicate entries.
Why: Pinpoints if approval triggers multiple publishes.
Step 3: Fix Post Ledger Quota (Short Prompt)
Goal: Count only successful posts, enforce 30-day limit.
Code:
javascript

Collapse

Wrap

Run

Copy
// server/routes.ts
const checkQuota = async (userId) => {
  const result = await db
    .select({ count: sql`COUNT(*)` })
    .from(posts)
    .where(sql`${posts.userId} = ${userId} AND ${posts.status} = 'success' AND ${posts.publishedAt} > NOW() - INTERVAL '30 days'`)
    .get();
  return result.count;
};
app.post('/approve-post', async (req, res) => {
  const userId = req.body.phone;
  const quota = await checkQuota(userId);
  const planLimit = 12; // Starter, adjust for user
  if (quota >= planLimit) return res.status(400).send('Quota exceeded');
  // Publish logic
  res.send('Approved');
});
Action: Save, run, test with one approval, query PostgreSQL: SELECT * FROM posts WHERE user_id = '+61424835189';.
Why: Ensures no carryover, counts successes only.
Step 4: Debug Retry Service (Short Prompt)
Goal: Stop post doubling from retries.
Code:
javascript

Collapse

Wrap

Run

Copy
// bulletproof-publisher.ts
const publishPost = async (post) => {
  const response = await fetch('https://api.x.com/2/tweets', { method: 'POST', body: JSON.stringify(post) });
  console.log('Publish response:', response.status); // Log status
  if (response.status === 400) {
    await new Promise(r => setTimeout(r, 300000)); // 5-min delay
    return publishPost(post); // Retry once
  }
  await db.update(posts).set({ status: response.ok ? 'success' : 'failed' }).where(eq(posts.id, post.id));
  return response.ok;
};
Action: Save, run, force a failed post, check logs and posts table for status.
Why: Limits retries, updates ledger post-response.
Step 5: Test and Verify (Short Prompt)
Goal: Confirm integrity.
Action:
As user (+61424835189), approve 2 posts.
Query: SELECT COUNT(*) FROM posts WHERE user_id = '+61424835189' AND status = 'success' AND published_at > NOW() - INTERVAL '30 days';
Check X/Facebook for posts, logs for errors.
Code (if needed):
javascript

Collapse

Wrap

Run

Copy
console.log('Test complete, count:', await checkQuota('+61424835189'));
Why: Validates quota and single posting.